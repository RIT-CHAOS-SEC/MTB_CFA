from structures import *
from utils import *
from parse_asm import *
import time
import argparse
from patch_ARM import *
import os

def arg_parser():
    '''
    Parse the arguments of the program
    Return:
        object containing the arguments
    '''
    parser = argparse.ArgumentParser()
    parser.add_argument('--asmfile', metavar='N', type=str, required=True,
                        help='Path to the .s asm files generated by objdump')
    parser.add_argument('--cfgfile', metavar='N', type=str, default='cfg.pickle',
                        help='Output file to store serialized CFG. Default is cfg.pickle')
    parser.add_argument('--arch', choices=SUPPORTED_ARCHITECTURES,help='Processor architecture.',
                        default='elf32-msp430')
    
    args = parser.parse_args()
    return args

def process_patch(pg, cfg, patch):
    ## two pass to update instructions of the patch now
    ## First iteration to update the instruction addresses
    patch.bytes = b''.join(patch.bin)
    if patch.instr[0].addr == None:
        pg.mode = 1
        for i in range(0, len(patch.instr)):
            instr = patch.instr[i]
            # print(f"Processing {instr.reconstruct()}")
            patch = add_instruction_ARM(instr, cfg, patch, pg, (None, i))

    ## set addresses of each instruction and correct the offests
    patch.type = 1
    pg.mode = 2
    for i in range(0, len(patch.instr)):
        instr = patch.instr[i]
        patch = add_instruction_ARM(instr, cfg, patch, pg, (None, i))
    patch.instr = sorted(patch.instr, key=lambda x: int(x.addr, 16))
    
    patch.bytes = b''.join(patch.bin)
    pg.patches[patch.addr] = patch
    pg.total_patches += 1
    pg.mode = 0
    patch.type = 0

    return pg

def instrument(cfg, asm_funcs):
    '''
    Function for instrumenting a binary from the diassembled instructions
    '''

    pg = PatchGenerator(cfg.arch.patch_base)

    tr_pg = PatchGenerator(cfg.arch.trampoline_region)

    MTBDR_MIN = 0x300008    
    MTBDR_MAX = 0x380000    
    # func_labels = ['application']#, 'NonSecure_LED_Off']

    # func = asm_funcs[cfg.label_addr_map['NonSecure_LED_Off']]
    for func_addr in asm_funcs.keys():
        print(func_addr)
        if MTBDR_MIN <= int(func_addr,16) and MTBDR_MAX > int(func_addr,16):
            print(f"doing {func_addr}")
            func = asm_funcs[func_addr]    
            i = 0
            while i < len(func.instr_list):
                instr = func.instr_list[i]
                alt_ret = ('pop' in instr.instr or 'ldr' == instr.instr) and 'pc' in instr.arg

                print(f"{instr.addr} {instr.reconstruct()}")
                if instr.instr in cfg.arch.conditional_br_instrs:
                    print(f"Conditional branch at {instr.addr}")
                    instr.arg = instr.arg.split(' ')[0]
                    prev_instr = func.instr_list[i-1]
                    
                    prev_instr = func.instr_list[i-1]
                    if '@' in instr.arg:
                        instr.arg = instr.arg.split('@')[0]
                    if '@' in prev_instr.arg:
                        prev_instr.arg = prev_instr.arg.split('@')[0]

                    ## add dir branch to the cb dest in MTBAR
                    mtbar_patch = Patch(instr.addr)
                    for k in range(0, 7):
                        asm = AssemblyInstruction(addr=None, instr='nop', arg=f'')
                        mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                    asm = AssemblyInstruction(addr=None, instr='b.w', arg=f'{instr.arg}')
                    mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                    pg = process_patch(pg, cfg, mtbar_patch)

                    # asm = AssemblyInstruction(addr=None, instr=prev_instr.instr, arg=f'{prev_instr.arg}')
                    # mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                    # asm = AssemblyInstruction(addr=None, instr=instr.instr, arg=f'{hex(int(instr.arg, 16)-4)}')
                    # mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                    
                    ## in TR region add cmp, cond_br to MTBAR, and b back to MTBDR
                    tr_patch = Patch(f'{instr.addr}-tr')
                    asm = AssemblyInstruction(addr=None, instr=prev_instr.instr, arg=f'{prev_instr.arg}')
                    tr_patch = add_instruction_ARM(asm, cfg, tr_patch, tr_pg)
                    asm = AssemblyInstruction(addr=None, instr=instr.instr, arg=f'{hex(int(mtbar_patch.instr[0].addr, 16)-4)}')
                    tr_patch = add_instruction_ARM(asm, cfg, tr_patch, tr_pg)

                    next_instr = func.instr_list[i+1]
                    print(next_instr.reconstruct())
                    if next_instr.instr in cfg.arch.unconditional_br_instrs:
                        asm = AssemblyInstruction(addr=None, instr='b.w', arg=f"{next_instr.arg}")
                    else:
                        asm = AssemblyInstruction(addr=None, instr='b.n', arg=f'{hex(int(prev_instr.addr, 16)+4)}')
                    print(asm.reconstruct())
                    tr_patch = add_instruction_ARM(asm, cfg, tr_patch, tr_pg)
                    tr_pg = process_patch(tr_pg, cfg, tr_patch)
                    
                    ## from MTBDR we need to b into the TR region
                    mtbdr_patch = Patch(f'{tr_patch.addr}-tr')
                    tr_addr = tr_patch.instr[0].addr[2:]
                    asm = AssemblyInstruction(addr=prev_instr.addr, instr='b.w', arg=f'{tr_addr}')
                    mtbdr_patch = add_instruction_ARM(asm, cfg, mtbdr_patch, pg)
                    pg = process_patch(pg, cfg, mtbdr_patch)

                elif instr.instr in cfg.arch.indr_calls: #indr_calls
                    print(f"Call at {instr.addr}")
                    ### add a trampoline to the call's dest
                    mtbar_patch = Patch(instr.addr)
                    asm = AssemblyInstruction(addr=None, instr='b.n', arg=f'{instr.arg}')
                    mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                    pg = process_patch(pg, cfg, mtbar_patch)
                    
                    ## add trampoline from og addr into MTBAR
                    tr_patch = Patch(f'{instr.addr}-tr')
                    asm = AssemblyInstruction(addr=instr.addr, instr=instr.instr, arg=f'{mtbar_patch.instr[0].addr[2:]}')
                    tr_patch = add_instruction_ARM(asm, cfg, tr_patch, pg)
                    pg = process_patch(pg, cfg, tr_patch)

                #''''
                elif alt_ret:
                    print(f"Return at {instr.addr}")
                    ## return is last instruction, and we need two spaces for the b.w
                    ## therefore, we take the previous instruction with us too
                    prev_instr = func.instr_list[i-1]
                    if '@' in instr.arg:
                        instr.arg = instr.arg.split('@')[0]
                    if '@' in prev_instr.arg:
                        prev_instr.arg = prev_instr.arg.split('@')[0]

                    #'''
                    print(f"checking {prev_instr.instr} in {cfg.arch.call_instrs}")
                    # a = input()
                    if prev_instr.instr in cfg.arch.call_instrs:
                        ## in this case: instr      =  pop/ldr to pc
                        ##               prev_instr =  a bl -- all other branch instructions are handled naturally


                        ## MTBAR implements the return instruction
                        mtbar_patch = Patch(instr.addr)
                        asm = AssemblyInstruction(addr=None, instr=instr.instr, arg=f'{instr.arg}')
                        mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                        pg = process_patch(pg, cfg, mtbar_patch)
                        print(" got here !")
                        ## trampoline region should have the prev instrucition, then a b.w. to the MTBAR
                        tr_patch = Patch(f'{prev_instr.addr}-tr')
                        asm = AssemblyInstruction(addr=None, instr=prev_instr.instr, arg=f"{prev_instr.arg.split(' ')[0]}")
                        tr_patch = add_instruction_ARM(asm, cfg, tr_patch, tr_pg)
                        asm = AssemblyInstruction(addr=None, instr='b.w', arg=f'{mtbar_patch.instr[0].addr[2:]}')
                        tr_patch = add_instruction_ARM(asm, cfg, tr_patch, tr_pg)
                        tr_pg = process_patch(tr_pg, cfg, tr_patch)
                        print(" got here !!")
                        ## direct branch in MTBDR to the trampoline region
                        mtbdr_patch = Patch(f'{tr_patch.addr}-tr')
                        asm = asm = AssemblyInstruction(addr=prev_instr.addr, instr='b.w', arg=f'{tr_patch.instr[0].addr[2:]}')
                        mtbdr_patch = add_instruction_ARM(asm, cfg, mtbdr_patch, pg)
                        pg = process_patch(pg, cfg, mtbdr_patch)
                        print(" got here !!!")
                    else:
                        #'''
                        print(instr.arg)
                        ### move ret instr and prev into the MTBAR
                        mtbar_patch = Patch(prev_instr.addr)
                        for k in range(0, 7):
                            asm = AssemblyInstruction(addr=None, instr='nop', arg=f'')
                            mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                        asm = AssemblyInstruction(addr=None, instr=prev_instr.instr, arg=f'{prev_instr.arg}')
                        mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                        asm = AssemblyInstruction(addr=None, instr=instr.instr, arg=f'{instr.arg}')
                        mtbar_patch = add_instruction_ARM(asm, cfg, mtbar_patch, pg)
                        pg = process_patch(pg, cfg, mtbar_patch)

                        # ### trampoline to the ret
                        tr_patch = Patch(f'{prev_instr.addr}-tr')
                        asm = AssemblyInstruction(addr=prev_instr.addr, instr='b.w', arg=f'{mtbar_patch.instr[0].addr[2:]}')
                        tr_patch = add_instruction_ARM(asm, cfg, tr_patch, pg)
                        pg = process_patch(pg, cfg, tr_patch)
                #'''
                i += 1

    # print("---------------")
    # for addr, patch in pg.patches.items():
    #     print(f"Patch at {addr}")
    #     for instr in patch.instr:
    #         print(instr)
    #     print('\n')

    ## iterate over the patches and add the 
    elf_file_path = 'instrumented.axf'
    count=0
    print("---- Updating ELF ----")
    for addr, patch in pg.patches.items():
        print(f"Updating ELF with patch {addr}...")
        for i in range(0, len(patch.instr)):
            instr_addr = int(patch.instr[i].addr, 16)
            print(f"Updating {patch.instr[i].addr} to {patch.bin[i]}")
            update_instruction(cfg.arch, elf_file_path, instr_addr, patch.bin[i])
        count += 1
        # break
    # a = input()
    print()
    for addr, patch in tr_pg.patches.items():
        print(f"Updating ELF with patch {addr}...")
        for i in range(0, len(patch.instr)):
            instr_addr = int(patch.instr[i].addr, 16)
            print(f"Updating {patch.instr[i].addr} to {patch.bin[i]}")
            update_instruction(cfg.arch, elf_file_path, instr_addr, patch.bin[i])
        count += 1
        # break
    # a = input()
    print()
    
    bash_cmd = "arm-none-eabi-objdump.exe -d ./instrumented.axf > ./instrumented.lst"
    os.system(bash_cmd)

def main():
    start = time.perf_counter()
    args = arg_parser()

    # Set arch if provided
    arch = set_arch(args.arch)

    # Parse asm file to python object
    lines = read_file(args.asmfile, arch.type)

    asm_func_file = args.cfgfile.replace("cfg", "asm_func")

    # Create the CFG from the asm file
    cfg, asm_funcs = create_cfg(arch, lines)

    # Serialize cfg to output file
    dump(cfg,args.cfgfile)

    dump(asm_funcs,asm_func_file)
    stop = time.perf_counter()
    timingFile = open('./logs/timing.log', 'w')
    print(f"Build CFG: {1000*(stop-start)} ms", file=timingFile)
    timingFile.close()

    debugFile = open("./logs/debug.log", "w")
    print("Nodes", file=debugFile)
    print("-------------------", file=debugFile)
    
    for node in cfg.nodes.keys():
        cfg.nodes[node].printNode(debugFile)
        print("", file=debugFile)
    print("-------------------", file=debugFile)
    print(f"Total Indr Calls: {len(cfg.indr_calls)}")
    
    if len(cfg.indr_calls) > 0:
        print("Indirect Calls:", file=debugFile)
        for addr in cfg.indr_calls:
            cfg.nodes[addr].printNode(debugFile)
        print("-------------------", file=debugFile)
        print("", file=debugFile)

    print(f"Total Indr Jumps: {len(cfg.indr_jumps)}")
    if len(cfg.indr_jumps) > 0:
        print("Indirect Jumps:", file=debugFile)
        for addr in cfg.indr_jumps:
            cfg.nodes[addr].printNode(debugFile)
        print("-------------------", file=debugFile)
        print("", file=debugFile)
    
    
    if len(cfg.func_nodes.keys()) > 0:
        print(f"Func nodes: {len(cfg.func_nodes.keys())}")
        for key in cfg.func_nodes.keys():
            print(f"{key}: {cfg.func_nodes[addr]}")
        print("-------------------", file=debugFile)
        print("", file=debugFile)

    print(f"Label addr map")
    for label in cfg.label_addr_map:
        print(f"{label} : {cfg.label_addr_map[label]}", file=debugFile)
    debugFile.close()

    print("Running instrument")
    instrument(cfg, asm_funcs)

if __name__ == "__main__":
    main()